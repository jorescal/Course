 

cd ~/Desktop/'IBM Course'/Github2/GitReps/Course







# First of all, create new Repo on Github

cd ~/Desktop/Github2/GitReps/	# create a new directory on your computer
mkdri Course			# every new directory needs to be create from the command line
cd Course 



git init
git config --global user.email "jorescal@gmail.com"


ls				# make sure you have the files you want to upload on the directory you are seeting


echo "# Data Science Course" >> README.md
git add README.md
git commit  -m "first commit of course notes xx/xx/2020"



git add 'IBM Course 4 Python for Data Science.txt'
git add 'for_loops.ipynb'

git commit  -m "commit # upedate XX of course notes date xx/xx/2020"

for_loops.ipynb

git remote add origin git@github.com:jorescal/Course.git
git push -u origin master





********** for every day update 


cd ~/Desktop/Github2/GitReps/Course


git add 'IBM Course 4 Python for Data Science.txt'
git add 'for_loops.ipynb'
git commit  -m "commit # XX of course notes date xx/xx/2020"
git push 




**************************

Glossary

iterate: repetir
argument:
List:
Tuple:
Variable:
"=" vs ":" 
operands:
operators:
expresion:
compound data types vs data types:
() vs []:
float:
int:
bool:
string:

.split()
.append()

del()
len()



A=((1),[2,3],[4])
A[2][0]


output

4


**************************




data types 

int -- a number (1,4,88,134523 )
float -- example 1.25653, 78.25, 1.5
string -- secuence of characters ("1", "car", "false")
boolean --True, False


We can change types on python. 

	for example a float as an int 
		int (2.2) = 2

NOTE
you could be lossing information.

	Or a an int to a boolean 
		bool(1) = True


Expresions 

45 + 5 + 9 

output

 59



	* Numbers are operands, 
	* Math symbols in this case, addition (+), are called operators.
	* the symbole "= " is also an operator however the ":" is not, it represetns the result of the expresion.

Python follows mathematical conventions when performing mathematical expressions.Python performs multiplication,then addition, to obtain the final result. The expressions in the parentheses are performed first.



Variables

We can use variables to store values. In this case, we assign a value of 1 to the "variable my_variable" using the assignment operator, i.e, the equal sign.


my_variable = 1


We can then use the value somewhere else in the code by typing the exact name of the variable. We will use a colon to denote the value of the variable. basics string operations in Python including indexing, escape sequences and operations.



expressions and variables: Expressions describe a type of operation the computers perform. Expressions are operations the python performs. For example, basic arithmetic operations like adding multiple numbers.



** compound data types



List and Tuples

Tuples: tuples are an ordered sequence variaboles represented as expressed using comma separated elements within parentheses. These are data types inside the parentheses.


In Python, there are different types of data values (strings, integer, float).

Expresion
45 + 10 + 3

variable
A = 10

	Tuples : expressed using comma separated elements within parentheses

carro = (  4, "diasco", 10.75) 


	List : A list is represented with square brackets.

carro = [4, "diasco", 10.75] 


with list's we can manipulate data the same way we do with tuples i.e.:


* Nesting: it means that list's can contain strengts, int, float, bool.

A  = ["test", 10, False, 45.893,]


* Index: We can access elements on a list based on the index structure:

A[0]: "test"

A[3]: 45.893


* Slincing: it allaws to pull a section of the data 

A[1:3]:[10, False]


* Concatenate or combine:

AA = A + [34, "perro"]

AA = ["test", 10, False, 45.893,34, "perro"]


List are mutable there for we can change them using using methods, for i. e.:


1)".extend()"

A  = ["test", 10, False, 45.893,]

A.extend(["pez", 9])

A  = ["test", 10, False, 45.893,"pez", 9]

In this case we add two new elements to the list





2) ".append()"

A  = ["test", 10, False, 45.893,]

A.append(["pez", 9])

A  = ["test", 10, False, 45.893,["pez", 9]]

In this case index [3] contains the new appendix ( A[3] : ["pez", 9] )



3) ".index()"


A  = ["test", 10, False, 45.893,]

A.index("test")




4) .split()

"hard Rock".split()

["hard", "Rock"]


i.e:

"A,B,C,D".split(",")

[A,B,C,D]



5) del("X"[X])

A = ["hard Rock", 10, False, 45.893,]

del(A[0])

A = [10, False, 45.893,]


6) Clone


Multiple names referring to the same object is known as aliasing

A = ["hard rock"]

A = B

B = ["hard rock"]


If we change "A" i.e.



A = ["banana"]


"B" changes ...


B = ["banana"]

You can clone "A" using the following sintax:


B = A[:]

Now if A changes B is not affected.



Note
Every time we apply a method, the list changes.If we apply extend, we add two new elements to the list. The list L is modified by adding two new elements. If we append the string A, we further change the list adding the string A.






*** Dictionaries in Python

To create a dictionary, we use curly brackets. The keys are the first elements. They must be immutable and unique. Each key is followed by a value separated by a colon. The values can be immutable, mutable, and duplicates. Each key and value pair is separated by a comma.

Dict = {"key1": 1, "key2": "2", "key3": [3, 3, 3], "key4": (4, 4, 4), ('key5'): 5, (0, 1): 6}
Dict

{'key1': 1,
 'key2': '2',
 'key3': [3, 3, 3],
 'key4': (4, 4, 4),
 'key5': 5,
 (0, 1): 6}


For every key, there can only be one single value, Keys can only be strings, numbers, or tuples, but values can be any data type.



Usfull commands


"dict_Name"['key']		# returns the value of the specific key.

"dict_Name".keys() 		# retrieve the keys of the dictionary using the method .keys(). 

"dict_Name".values() 		# You can retrieve the values using the method .values().

"dict_Name"['key'] = 'value'	# use this command to add a new key + value to the dic.

del("dict_Name"['key'])		# use "del" to delete key inside dic.

"Key" in dict_Name   		# use "in" to fis a value inside the dic. 



Note

	NO "" requiered for the "dict_Name"




****** Set


Set's are also a type of collection. Sets are a type of collection. This means that like lists and tuples, you can input different Python types. Unlike lists and tuples, they are unordered. This means sets do not record element position. Sets only have unique elements. This means there is only one of a particular element in a set. To define a set, you use curly brackets.



set1 = {"pop", "rock", "soul", "hard rock", "rock", "R&B", "rock", "disco"}
set1

{'R&B', 'disco', 'hard rock', 'pop', 'rock', 'soul'}



Usfull commands


Data_set = set(Data_list)   		# To create a set from a list.

Data_set.add("element")			# add an element to a set using the ".add()" method. 

Data_set.remove("element")		# remove an item from a set using the "remove()" method. 

"element" in Data_set			# verify if an element is in the set using the "in" command.

intersection = Data_set1 & Data_set2	# You can find the intersect of two sets using "&".

Data_set1.difference(Data_set2)		# You can find all the elements that are not shared betwen   
	
or 

Data_set2.difference(Data_set1)		# Data set's using the ".difference()" method

Data_set1.intersection(Data_set2)   	# You can also find the intersection elements betwen 2 sets using 					  		  the ".intersection()" method

Data_set1.union(Data_set2)		# you can merge 2 sets elements by using the ".union()" method.

set(Data_set1).issuperset(Data_set2)   	# you can check if a set is a superset or subset of another set, 					  		  respectively by using the ".issuperset()" method.



*********** Conditions and Branching


Comparison operations compare some value or operand and, based on a condition, they produce a Boolean. When comparing two values you can use these operators:

equal: 				==
not equal: 			!=
greater than: 			>
less than: 			<
greater than or equal to: 	>=
less than or equal to: 		<=


example 

	i = 2
	i > 5

False


Branching allows us to run different statements for different inputs.

we use the following statements 


Statement	True		False

if		perform task 	keep going
elif 		perform task	keep going
else		perform task	keep going





# If statement example

age = 19
#age = 18

#expression that can be true or false
if age > 18:
    
    #within an indent, we have the expression that is run if the condition is true
    print("you can enter" )

#The statements after the if statement will run regardless if the condition is true or false 
print("move on")





# Else statement example

age = 18
# age = 19

if age >= 18:
    print("you can enter" )
else:
    print("go see Meat Loaf" )
    
print("move on")





# Elif statment example

age = 18

if age > 18:
    print("you can enter" )
elif age == 18:
    print("go see Pink Floyd")
else:
    print("go see Meat Loaf" )
    
print("move on")







album_year = 1983
#album_year = 1970



if album_year > 1980:

    print("Album year is greater than 1980")
else:
    print("less than 1980")

print('do something..')



# Condition statement example


Logical operators allow you to combine or modify conditions.

and
or
not

The and statement is only True when both conditions are true. The or statement is true if one condition is True. The not statement outputs the opposite truth value.




# Condition statement example


Exmple Using "And":

album_year = 1980

if(album_year > 1979) and (album_year < 1990):
    print ("Album year was in between 1980 and 1989")
    
print("")
print("Do Stuff..")




Exmple Using "Or":

album_year = 1990

if(album_year < 1980) or (album_year > 1989):
    print ("Album was not made in the 1980's")
else:
    print("The Album was made in the 1980's ")




Exmple Using "not":

album_year = 1983

if not (album_year <= 1980):
    print ("Album year is not from the 80's")




***************Loops


We will look at two types of loops, for loops and while loops.


Range

Before we discuss loops lets discuss the range object. It is helpful to think of the range object as an ordered list. If we would like to generate a sequence that contains three elements ordered from 0 to 2 we simply use the following command:

range(3)


If the input (in this case "3" ) is a positive integer, the output is a sequence ( 0 to 2 ). The sequence contains the same number of elements as the input but starts at zero.


In the other hand If the range function has two inputs:



range (10, 15) 


Where the first input is larger than the second input, the output is a sequence that starts at the first input.  

[10, 11, 12, 13, 14]


LOOP


What is for loop? 

The for loop enables you to execute a code block multiple times.


for i in range(0, 8):
    print(i)



NOTE:

we read:


for  (i =  variable that define the index of a list during the loop ) in ("range range(0, 8)" the lengt of the list that will be created )

print ("i")  --> print the index and increase on one starting from the reference gived on the range function "range range(0, 8)" 


Output

0
1
2
3
4
5
6
7


Where "i" is an idex in a range from 0 to 8. Eventually the range culd be a list 


Other example will be:


dates = [1982,1980,1973]
N = len(dates)

for i in range(N):
    print(dates[i])   

output

1982
1980
1973


or in a more simple matter 


dates = [1982,1980,1973]

for year in dates:
    print(year) 

1982
1980
1973


The way to read the code will be:

		for "# of index" in "List":
			print(index # XX...)




What is while loop?
As you can see, the for loop is used for a controlled flow of repetition. However, what if we don't know when we want to stop the loop? What if we want to keep executing a code block until a certain condition is met? The while loop exists as a tool for repeated execution based on a condition. The code block will keep being executed until the given logical condition returns a False boolean value.






dates = [1982, 1980, 1973, 2000]	#define the list

i = 0					# search begins in index 0 in  this case of list "dates" 
year = 0				# we define the reference to stop on the while loop 

while(year != 1973):			# while (index "not equal to" variable target
    year = dates[i]			# year changes from a "year = 0" to "dates[0]" in the first iteration				
    i = i + 1
    print(year)

print("It took ", i ,"repetitions to get out of loop.")









dates = [1982, 1980, 1973, 2000]	# define the list

i = 0					# since this is a loop we need to define variables for starting points
year = 0				

while(year != 1973):			# while (0 not equal 1973), if "True" apply next line, if False jump to "print("It.." and end the loop
    year = dates[i]			# year 	=  dates[0] = 1982	
    i = i + 1				# i = 0 + 1  // i = 1
    print(year)				# print(1982)

print("It took ", i ,"repetitions to get out of loop.")



****************


if
elif
else
print

for "index" in "range"
print


list [1,2,3]
index value = list[0]

while( index value == reference value to filter )
	index value == index value + 1
	newList.append (list[index value])
	print (newList.append)
print (end)



****************	   ****************	
**************** Functions ****************



Print Vs Return – Python Principles

Printing and returning are completely different concepts. print is a function you call. Calling print will immediately make your program write out text for you to see. ... When a return statement is reached, Python will stop the execution of the current function, sending a value out to where the function was called.




You can define functions to provide the required functionality. Here are simple rules to define a function in Python:

Functions blocks begin def followed by the function name and parentheses ().
There are input parameters or arguments that should be placed within these parentheses.
You can also define parameters inside these parentheses.
There is a body within every function that starts with a colon (:) and is indented.
You can also place documentation before the body
The statement return exits a function, optionally passing back a value
An example of a function that adds on to the parameter a prints and returns the output as b:



a = "caballo"
b = "banano"

def con(x, j):

    print (x)
    print (j)
    c = 1
    d = 43
    return (c+d)


# con(x, j)
con(a, b)
x = con(a, b)
print(x)
x


Output

caballo
banano
caballo
banano
44
44




****************	   ****************	
****************Class:



Class isthe combination of an Objects (class type ) and Attributes